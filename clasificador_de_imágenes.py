# -*- coding: utf-8 -*-
"""Clasificador de imágenes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LXt5fMxI5hA3Cga3L7fntzMXIyeF37s_
"""

import tensorflow as tf
import tensorflow_datasets as tfds

#cargar dataset
data, metadata = tfds.load('cifar100', with_info=True, as_supervised=True)

metadata

train_data, test_data = data['train'], data['test']

class_names = metadata.features['label'].names

class_names

def normalize(imagenes, etiquetas):
  imagenes = tf.cast(imagenes, tf.float32)
  imagenes /= 255
  return imagenes, etiquetas

train_data = train_data.map(normalize)
test_data = test_data.map(normalize)

train_data = train_data.cache()
test_data = test_data.cache()

for image, label in train_data.take(1):
    resized_image = tf.image.resize(image, [32, 32])

print(resized_image.shape)

import matplotlib.pyplot as plt

#Dibujar dibujar
plt.figure()
plt.imshow(image, cmap=plt.cm.binary)
plt.colorbar()
plt.grid(False)
plt.show()

plt.figure(figsize=(10,10))
for i, (image, label) in enumerate(train_data.take(15)):
  resized_image = tf.image.resize(image, [32, 32])
  plt.subplot(5,5,i+1)
  plt.xticks([])
  plt.yticks([])
  plt.grid(False)
  plt.imshow(image, cmap=plt.cm.binary)
  plt.xlabel(class_names[label])
plt.show()

modelo = tf.keras.Sequential([
  tf.keras.layers.Flatten(input_shape=(32,32,3)),
  tf.keras.layers.Dense(50, activation=tf.nn.relu),
  tf.keras.layers.Dense(50, activation=tf.nn.relu),
  tf.keras.layers.Dense(100, activation=tf.nn.softmax) #Para redes de clasificacion
])

modelo.compile(
    optimizer='adam',
    loss=tf.keras.losses.SparseCategoricalCrossentropy(),
    metrics=['accuracy']
)

num_ej_train = metadata.splits["train"].num_examples
num_ej_test = metadata.splits["test"].num_examples
print(num_ej_test)
print(num_ej_train)

TAMANO_LOTE = 32
train_data = train_data.repeat().shuffle(num_ej_train).batch(TAMANO_LOTE)
test_data = test_data.batch(TAMANO_LOTE)

import math

#Entrenar modelo
historial = modelo.fit(train_data, epochs=5, steps_per_epoch= math.ceil(num_ej_train/TAMANO_LOTE))

for image, label in train_data.take(1):
    print("Forma de la imagen:", image.shape)
    print("Forma de la etiqueta:", label.shape)

#funcion
plt.xlabel("# Epoca")
plt.ylabel("Magnitud de pérdida")
plt.plot(historial.history["loss"])

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc
import tensorflow as tf
from sklearn.preprocessing import LabelBinarizer

for test_images, test_labels in test_data.take(1):
    test_images = test_images.numpy()
    test_labels = test_labels.numpy()

# Calcular la curva ROC y AUC
fpr, tpr, _ = roc_curve(test_labels, np.max(predicciones, axis=1), pos_label=1)
roc_auc = auc(fpr, tpr)

plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

import numpy as np
import matplotlib.pyplot as plt

for test_images, test_labels in test_data.take(1):
    test_images = test_images.numpy()
    test_labels = test_labels.numpy()

# Realizar predicciones
predicciones = modelo.predict(test_images)


class_name = [str(i) for i in range(predicciones.shape[1])]

def graficar_imagen(i, arr_predicciones, etiquetas_reales, imagenes):
    arr_predicciones, etiqueta_real, img = arr_predicciones[i], etiquetas_reales[i], imagenes[i]
    plt.grid(False)
    plt.xticks([])
    plt.yticks([])

    plt.imshow(img[..., 0], cmap=plt.cm.binary)

    etiqueta_prediccion = np.argmax(arr_predicciones)
    color = 'blue' if etiqueta_prediccion == etiqueta_real else 'red'

    plt.xlabel("{} {:2.0f}% ({})".format(class_names[etiqueta_prediccion],
                                100 * np.max(arr_predicciones),
                                class_names[etiqueta_real]),
                color=color)

def graficar_valor_arreglo(i, arr_predicciones, etiqueta_real):
    arr_predicciones_i = arr_predicciones[i]
    etiqueta_real_i = etiqueta_real[i]

    plt.grid(False)
    plt.xticks([])
    plt.yticks([])

    grafica = plt.bar(range(len(arr_predicciones_i)), arr_predicciones_i, color="#777777")
    plt.ylim([0, 1])

    etiqueta_prediccion = np.argmax(arr_predicciones_i)

    grafica[etiqueta_prediccion].set_color('red')
    grafica[etiqueta_real_i].set_color('blue')

# Graficar imágenes y sus predicciones
filas = 5
columnas = 5
num_imagenes = filas * columnas
plt.figure(figsize=(2 * 2 * columnas, 2 * filas))

for i in range(min(num_imagenes, len(test_images))):
    plt.subplot(filas, 2 * columnas, 2 * i + 1)
    graficar_imagen(i, predicciones, test_labels, test_images)
    plt.subplot(filas, 2 * columnas, 2 * i + 2)
    graficar_valor_arreglo(i, predicciones, test_labels)

plt.tight_layout()
plt.show()

image = test_images[0]
image = np.array([image])
prediccion = modelo.predict(image)

print("Prediccion: " + class_names[np.argmax(prediccion[0])])

from sklearn.metrics import accuracy_score

predicciones_clase = np.argmax(predicciones, axis=1)

precision = accuracy_score(test_labels, predicciones_clase)
print(f'Precisión: {precision:.4f}')